## 连线功能

- 计算出 item 中心位置,计算出删 svg 的起始位置和 line 的结束位置
  - 因为子项目可以移动,所以 svg 的起始位置可能不是父节点中心而是子节点中心
- 

## 编辑 title 功能

- contenteditable: false 的元素, 双击自动改成 true,并自动获取焦点(focus()无效 )
  1. 因为 false 改成 true 后,要 nextTick 可以再获取焦点
- tab 在浏览器的默认事件

## 拖拽item

- 不跟手
  - 因为注册了 item.onmouseleave 事件, 导致鼠标离开 item 时会 isMoving=false,停止移动
  - 删掉这一事件, 快速拖动过程不跟手,但是最终位置是不变的

## 画布

### 拖动画布

- `window.scrollTo(window.scrollX - event.movementX / scale, window.scrollY - event.movementY/scale);`
  - 缩小时拖动,移动同样鼠标距离滚动条移动px要更多
- 

### 缩放

- 保证中心位置缩放后还在中心
  - 用scale控制designer缩放，里面所有内容都会缩放。他们的实际大小不会变比如width，margin，left, clientWidth。 但是会影响getBoundingClient().x  和 getBoundingClient().width; computedStyle 不会变
  - 把designer 的 transform-origin: 0 0;
  - 放大后原始中心位置会向右下角偏移， 再用window.scrollTo() 来把视口向右下角移动。这样就能保证中心位置缩放后还在中心。

> 遇到的问题：
>
> fixed定位的元素，如果其父元素带transform则不会再相对于视口，而是相对于其父元素

* 用到了防抖思想
  * 缩放时展示缩放倍率

### 框选

因为框选会受到scale莫名其妙的影响,选择起点就会很难,所以我想绕过scale的影响

1. 获取起点相对于文档的坐标 `e.pageX`,也就是相对于designer的坐标,但是文档是没有scale效果的
2. 通过 `left = e.pageX / scaleRatio` 得到了其应该在desginer元素上的绝对定位坐标

### 背景

- 整体太大,不能直接创建
  - 只创建视口部分, 放大缩小根据缩放比例调整网格密度,依然消耗性能
- 利用 background-img 重复填充的特性

```html
<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50">
  <path d="M25 0 v50" stroke="black" stroke-opacity="0.1" stroke-dasharray="16,4" />
  <path d="M0 25 h50" stroke="black" stroke-opacity="0.1" stroke-dasharray="16,4" />
</svg>
```

## 滚动恢复

* window.scrollTo失效
  * 当我打开一个页面然后手动滚动到其他地方后，再刷新页面，此时页面会闪到scrollTo的位置，然后立刻闪回我上次手动滚动到的位置。

```js
if ('scrollRestoration' in history) {
    history.scrollRestoration = 'manual';
} 
```

> history 也是浏览器全局属性

## 右键菜单-指令

* *为什么createApp时传入ref props 不会自动解包？？？*
* 全局指令必须在app.mount之前注册！
* 具有复用性

## 迭代递归

## 事件总线

采用 `发布-订阅者模式`， 在designer监听delete键盘事件，publish。每个DragItem都订阅delete事件。

> 原本采用在DragItem里每个都注册delete键盘事件，利用了闭包特性。但是这样导致tab后加入的节点delete事件注册晚，而事件处理谁先注册谁先处理。从而导致在同时删除它和它的父节点时先删除了父节点，把所有儿子节点移给了爷爷节点。儿子节点会销毁再重新生成，儿子节点的事件处理函数也随着组件再销毁重新生成。导致原本应该处理delete事件的处理函数失效，删不掉儿子节点。

## 感受

### 1. 前期打好架构真的很重要

比如吃亏在比如缩放功能，

前期直接利用ctrl+滚轮来缩放，还有再控制一下缩放中心始终以画面中心

然后因为 发现所有东西都被缩放了，所以又改用scale 来缩放designer

最后觉得早知道整个designer可以用svg来做，利用viewbox 来实现缩放


## 利用微队列 - 优化

因为我页面中所有项都是由vue根据TopItems数组来生成的。所以当我刚刚调用createDragItem完还没有拿到dom节点。

紧接着我又要做一些操作要用到dom节点的宽高。所以我想到了用 `Promise.resolve().then() ` 其实用nextTick也是一样的

```js
    async function initProject() {
        const isSuccess = await importProject()
        console.log('isSuccess', isSuccess)
        if (!isSuccess) {
            console.log('自动初始化3个节点')
            const root = createDragItem(null)
            createDragItem(root)
            createDragItem(root)
            // onUpdated(() => {
            // root.standardizeChildrenPos();
            // })
            Promise.resolve().then(() => {
                root.standardizeChildrenPos();
            })
        }
    }
```

## 保存 IndexedDb / localforage - 优化

1. 异步操作，性能好
2. 数据类型支持丰富，包含数组，对象，和二进制

原本使用localstorage存储，还需要使用 `JSON`编码和解码。
